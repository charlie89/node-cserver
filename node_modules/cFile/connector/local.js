var fs = require("fs");
var sys = require("sys");
var mime = require("mime");
var exec = require('child_process').exec;
var cPath = require('cPath');

exports.connect = function(req, res, options, query) {
    switch (query.action) {
	case 'browse':
	    browse(req, res, options, query);
	    break
	case 'mkdir':
	    mkdir(req, res, options, query);
	    break
	case 'mkfile':
	    mkfile(req, res, options, query);
	    break
	case 'remove':
	    remove(req, res, options, query);
	    break
	case 'copy':
	    copy(req, res, options, query);
	    break
	case 'move':
	    move(req, res, options, query);
	    break
	case 'rename':
	    rename(req, res, options, query);
	    break
	case 'load':
	    load(req, res, options, query);
	    break
	case 'save':
	    save(req, res, options, query);
	    break
	default:
	    res.end(JSON.stringify({
		error: 'Function not available.'
	    }));
    }
}

function browse(req, res, options, query) {
    var path = query.path;
    var fullpath = options.basePath + path;
    fs.readdir(fullpath, function(err, files) {
	if (err) {
	    res.end(JSON.stringify({
		error: err
	    }));
	    return;
	}
	var length = files.length;
	var actual = 0;
	// TODO: check if realpath is accessible (sessions und path nachgucken)
	var results = [{
	    name: "..",
	    path: cPath.getUpperPath(path),
	    filename: "..",
	    mimeType: "directory",
	    size: 4096,
	    timeAccessed: 0,
	    timeCreated: 0,
	    timeModified: 0,
	    isDirectory: true,
	    isFile: false
	}];
	files.forEach(function(filename) {
	    var file = path + filename;
	    fs.stat(fullpath + filename, function(err, stat) {
		if (err) send(res, path, results);
		var mimetype = "";
		if (stat.isDirectory()) {
		    mimetype = "directory";
		    generateBrowseObject();
		} else {
		    exec("mimetype -b " + fullpath + filename, function(error, stdout, stderr) {
			if (error) {
			    mimetype = mime.lookup(file);
			} else mimetype = stdout;
			generateBrowseObject();
		    });
		}

		function generateBrowseObject() {
		    actual++;
		    //var mimetype = stat.isDirectory() ? "directory" : mime.lookup(file);
		    var result = {
			name: cPath.getFileName(filename),
			path: file + (stat.isDirectory() ? "/" : ""),
			filename: filename,
			mimeType: mimetype,
			image: "image/mimetypes/" + mimetype.replace("/", "-") + ".png",
			size: stat.size,
			timeAccessed: stat.atime,
			timeCreated: stat.ctime,
			timeModified: stat.mtime,
			isDirectory: stat.isDirectory(),
			isFile: stat.isFile()
		    };
		    results.push(result);
		    if (actual == length) {
			send(res, path, results);
		    }
		}
	    });
	});
	if (length <= 0) {
	    send(res, path, results);
	}
    });

    function send(res, path, content) {
	var json = {
	    header: {
		path: path
	    },
	    content: content
	};
	res.write(JSON.stringify(json));
	res.end();
    }
}

function mkdir(req, res, options, query) {
    var fullpath = options.basePath + query.path;
    fs.mkdir(fullpath + query.name, 777, function(err) {
	var result = {
	    header: {
		name: query.name
	    }
	};
	if (err) result.error = err;
	res.end(JSON.stringify(result));
    });
}

function mkfile(req, res, options, query) {
    res.end(JSON.stringify({
	error: 'Not implemented yet.'
    }));
}

function remove(req, res, options, query) {
    var callback = function(err) {
	var result = {
	    header: {
		name: query.name
	    }
	};
	if (err) result.error = err;
	res.end(JSON.stringify(result));
    }
    var fullpath = options.basePath + query.path;
    fs.stat(fullpath, function(err, stat) {
	if (err) callback(err);
	if (stat.isDirectory()) { //TODO recursive delete contents
	    fs.rmdir(fullpath, function(err) {
		callback(err)
	    });
	} else {
	    fs.unlink(fullpath, function(err) {
		callback(err)
	    });
	}
    });
}

function _copy_or_move(req, res, options, query, unlink) {
    var callback = function(err) {
	var result = {
	    header: {
		name: query.newpath.split("/").pop()
	    }
	};
	if (err) result.error = err;
	res.end(JSON.stringify(result));
    };
    var path = options.basePath;
    var frompath = path + query.path;
    var topath = require('path').normalize(path + query.newpath);
    console.log("From " + frompath);
    console.log("  To " + topath);
    fs.readFile(frompath, function(err, data) {
	fs.writeFile(topath, data, function(err) {
	    if ((!err) && (unlink)) fs.unlink(frompath, function(err) {
		callback(err);
	    });
	    else callback(err);
	});
    });
}

function copy(req, res, options, query) {
    _copy_or_move(req, res, options, query, false);
}

function move(req, res, options, query) {
    _copy_or_move(req, res, options, query, true);
}

function rename(req, res, options, query) {
    var fullpath = options.basePath + query.path;
    fs.rename(fullpath + query.filename, fullpath + query.newfilename, function(err) {
	var result = {
	    header: {
		name: query.newfilename
	    }
	};
	if (err) result.error = err;
	res.end(JSON.stringify(result));
    });
}

function load(req, res, options, query) {
    var path = options.basePath + query.path;
    var readStream = fs.createReadStream(path);
    readStream.addListener('error', function (err) {
	console.log('error reading'+path+sys.inspect(err));
	res.write('404');
	res.end();
	console.log("wrote 404");
    });
    readStream.addListener('fd', function(fd) {
	console.log("opened" + path+"on fd"+fd);
    });
    req.connection.addListener('timeout', function() {
	/* dont destroy it when the fd's already closed */
	if (readStream.readable) {
	    console.log('timed out. destroying file read stream');
	    readStream.destroy();
	}
    });
    res.addListener('error', function (err) {
	console.log('error writing'+path+sys.inspect(err));
	readStream.destroy();
    });
    sys.pump(readStream, res);
}

function save(req, res, options, query) {
    var body = '';
    if (req.method == 'POST') {
	req.on('data', function(data) {
	    body += data;
	});
	req.on('end', function() {
	    var fullpath = options.basePath + query.path;
	    if (typeof(query.qqfile) != "undefined") fullpath += query.qqfile; //handle valums uploader
	    fs.writeFile(fullpath, decodeURI(body), function(err) { // TODO: can only upload ASCII, no images
		if (err) res.end(JSON.stringify({
		    error: err
		}));
		else res.end(JSON.stringify({
		    state: "success"
		}));
	    });
	});
    } else res.end(JSON.stringify({
	error: 'Use POST to upload files.'
    }));
}




