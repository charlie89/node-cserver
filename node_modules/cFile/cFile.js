var fs = require('fs');
var path = require('path');
var gzip = require('gzip');

exports.route = [{
   api: 'file',
   method: 'GET',
   callback: browse
}];

function browse(req, res) {
   require('cDB').get(req, res, function (result) {
      var json = {
         header: {
            path: ''
         },
         content: result
      };
      res.end(JSON.stringify(json));
   });
}

function route_old(req, res, api_length) {
   var url = require("url").parse(req.url, true);
   var link = url.pathname.substring(api_length).split('/');
   var action = link.shift();
   var location = link.shift();
   var query = url.query;
   if (typeof (query.path) == 'undefined') query.path = link.join('/');
   query.action = action;
   console.log("cFile: location:" + location + ' action:' + action + ' path:' + query.path);
   var locations = [];
   locations['local'] = {
      connector: 'local',
      options: {
         basePath: require("cPath").getRootDir()
      }
   };
   locations['charlieweb'] = {
      connector: 'php',
      options: {
         host: 'charlieweb.co.de',
         port: 80,
         path: '/cweb.php'
      }
   };
   if (!locations[location]) {
      res.end(JSON.stringify({
         error: 'Location not available'
      }));
      return;
   }
   var loc = locations[location];
   switch (loc.connector) {
   case 'local':
      require('./connector/local.js').connect(req, res, loc.options, query);
      break
   case 'php':
      require('./connector/php.js').connect(req, res, loc.options, query);
      break
   default:
      res.end(JSON.stringify({
         error: 'cFile: Connector not available. Please check the configuration.'
      }));
   }
}

var getBuffer = (function () {
   var buffers = {};

   function addBuffer(path) {
      if (path in buffers) {
         return;
      }
      buffers[path] = null;
      fs.watchFile(path, function () {
         buffers[path] = null;
      });
   }
   return function getBuffer(filePath, callback) {
      if (buffers[filePath]) {
         return callback(null, buffers[filePath]);
      }
      path.exists(filePath, function (exists) {
         if (!exists) {
            return callback("file-not-found", null);
         }
         fs.readFile(filePath, function (err, data) {
            if (err) {
               callback(err);
            };
            gzip(data, function (err, buf) {
               if (err) throw err;
               addBuffer(filePath);
               buffers[filePath] = buf;
               callback(err, buf);
            });
         });
      });
   };
})();

var staticFile = (function () {
   function handler(path, mimeType, req, res) {
      getBuffer(path, function (err, buffer) {
         if (err === "file-not-found") {
            console.error("Couldnt find file: " + path);
            return res.error404();
         }
         if (err) {
            throw err;
         };
         res.writeHead(200, {
            'Content-Encoding': 'gzip',
            "Content-Length": buffer.length,
            "Content-Type": mimeType
         });
         res.end(buffer, "binary");
      });
   }
   return function staticFile(path, mime) {
      return function (req, res) {
         handler(path, mime, req, res);
      };
   };
})();

function staticDir(fileDir, mimeLookup) {
   for (var key in mimeLookup) {
      if (key.charAt(0) !== ".") {
         console.warn("Extension found without a leading periond ('.'): '" + key + "'");
      }
   }
   return function (req, res) {
      var filePath = path.join(fileDir, req.cURL.pathname);
      var ext = path.extname(filePath).toLowerCase();
      if (!(ext in mimeLookup)) {
         console.error("Couldnt find file: " + filePath);
         return res.error404();
      }
      getBuffer(filePath, function (err, buffer) {
         if (err === "file-not-found") {
            console.error("Couldnt find file: " + filePath);
            return res.error404();
         }
         if (err) {
            throw err;
         }
         res.writeHead(200, {
            'Content-Encoding': 'gzip',
            "Content-Length": buffer.length,
            "Content-Type": mimeLookup[ext]
         });
         res.end(buffer, "binary");
      });
   };
}

exports.staticFile = staticFile;
exports.staticDir = staticDir;